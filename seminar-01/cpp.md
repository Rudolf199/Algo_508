# Краткий ликбез по C++ для алгоритмов 

## 1. Структура программы

```cpp
#include <bits/stdc++.h> // подключаем почти все стандартные библиотеки

int main() {
    std::ios::sync_with_stdio(false); // ускоряем ввод/вывод
    std::cin.tie(nullptr);            // отключаем привязку cin к cout

    std::cout << "Hello, world!\n";  // выводим текст на экран
    return 0;                         // возвращаем 0 → программа завершилась успешно
}
```

* `#include` — подключение библиотек
* `main()` — главная функция, с которой начинается выполнение
* `{}` — тело функции
* `return 0;` — завершение программы

---

## 2. Пространства имён (`namespace`)

```cpp
std::cout << "Hello\n";                 // вывод
std::vector<int> v = {1, 2};           // вектор
std::sort(v.begin(), v.end());         // сортировка элементов v.begin()/v.end() -> итераторы на начало и конец вектора  


// (пока не важно что это, пусть будет указатель на максималках)

namespace myspace {                     // создаём своё пространство имён
    int add(int a, int b) { return a+b; } // можно обьявлять функции, переменные и тд
    int A = 5;
}

int x = myspace::add(2,3);              // вызываем функцию через ::
```

* `std::` — стандартная библиотека
* `::` — оператор разрешения области имён

---

## 3. Типы данных

```cpp
int a = 5;                  // целое число, 4 байта

long long b = 1000000000000; // большое число, 8 байт

int64_t c = 123456789012345; // точно 64-битный int (используем его!) есть еще int32_t и тп

double d = 3.14;             // вещественное число

char e = 'A';                 // символ

bool f = true;                // логический тип

std::string s = "hi";         // строка
```



## Арифметические операторы в C++

```cpp
#include <iostream>

int main() {
    int a = 10;   // объявление и инициализация переменной a
    int b = 3;    // объявление и инициализация переменной b

    int sum = a + b;      // сложение → 10 + 3 = 13
    int diff = a - b;     // вычитание → 10 - 3 = 7
    int prod = a * b;     // умножение → 10 * 3 = 30
    int div = a / b;      // целочисленное деление → 10 / 3 = 3
    int mod = a % b;      // остаток от деления → 10 % 3 = 1

    std::cout << sum << " " << diff << " " << prod << " " << div << " " << mod << "\n";
}
```

**Объяснение:**

* `+` — сложение
* `-` — вычитание
* `*` — умножение
* `/` — деление (для int — целочисленное, дробная часть отбрасывается)
* `%` — остаток от деления (только для целых чисел)

---

### Примечания:

1. Для вещественных чисел (`double`):

```cpp
double x = 10.0, y = 3.0;
std::cout << x / y; // 3.33333
```

2. Арифметические операторы можно комбинировать и использовать в выражениях:

```cpp
int z = (a + b) * 2 - 5;
```

3. В C++ есть **приоритет операций**, как в математике:

* `*`, `/`, `%` выше, чем `+`, `-`
* Скобки `()` меняют приоритет


---

## Приведение типов (Casting) в C++

**Приведение типов** — это процесс, когда мы явно или неявно говорим компилятору: «Рассматривай это значение как другой тип».

### 1. Неявное приведение

* Компилятор сам преобразует тип, если это безопасно.

```cpp
int a = 5;
double b = a; // int автоматически преобразуется в double
```

### 2. Явное приведение (касты)

Мы сами управляем преобразованием.

---

### 2.1 `static_cast`

* Преобразует типы, известные на этапе компиляции.
* Безопасен для чисел и указателей в иерархии классов (если преобразование допустимо).

```cpp
int a = 10;
double b = static_cast<double>(a); // int → double

class Base {};
class Derived : public Base {};

Derived* d = new Derived();
Base* bptr = static_cast<Base*>(d); // Derived → Base безопасно
```

---

### 2.2 `dynamic_cast`

* Используется для **безопасного преобразования указателей и ссылок в иерархии классов**.
* Работает только с полиморфными классами (есть хотя бы один `virtual` метод).
* Возвращает `nullptr`, если преобразование невозможно.

```cpp
class Base { virtual void f() {} };
class Derived : public Base {};

Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b); // безопасно
if(d != nullptr) std::cout << "Преобразование прошло\n";
```

---

### 2.3 `const_cast`

* Убирает или добавляет `const` у переменной.
* Используется редко, когда нужно изменить объект, который был объявлен как `const`.

```cpp
const int x = 5;
int* y = const_cast<int*>(&x); // убираем const
*y = 10; // теперь можно изменить (опасно!)
```

---

### 2.4 `reinterpret_cast`

* Преобразует один тип указателя в другой **без проверки корректности**.
* Очень низкоуровневый, нужно использовать с осторожностью.

```cpp
int a = 65;
char* p = reinterpret_cast<char*>(&a); // смотрим на int как на char
std::cout << *p << "\n"; // может вывести символ 'A' на некоторых системах
```

---

### 2.5 C-style cast (старый способ)

* Пример: `(double)a`
* Работает как комбинация `static_cast`, `const_cast` и `reinterpret_cast`.
* Менее безопасен, **крайне не рекомендуется** в современном C++.

```cpp
int a = 10;
double b = (double)a; // int → double
```

---

### Сравнение кастов

| Каст               | Когда использовать                    | Безопасность                                           |
| ------------------ | ------------------------------------- | ------------------------------------------------------ |
| `static_cast`      | Числа, указатели в иерархии           | Безопасно, проверка компилятором                       |
| `dynamic_cast`     | Указатели/ссылки в иерархии классов   | Безопасно, возвращает nullptr при ошибке               |
| `const_cast`       | Добавление/удаление const             | Опасно, если изменять действительно константные данные |
| `reinterpret_cast` | Любое низкоуровневое преобразование   | Не безопасно, компилятор не проверяет                  |
| C-style cast       | Любое явное приведение (старый стиль) | Менее безопасно, не рекомендуется                      |



---

## 4. Области видимости и память

### 4.1 Стек

```cpp
void foo() {
    int x = 5;  // объявление и инициализация переменной x в стеке
} // при выходе из foo x удаляется автоматически
```

### 4.2 Куча

```cpp
int* arr = new int[5];  // создаём массив в куче
arr[0] = 10;            // обращаемся к элементу
delete[] arr;           // освобождаем память

// для освобождения памяти по поинтеру есть обычный delete, A - структура
A* p = new A();
delete p;
```

**Правила**

* Стек: память управляется автоматически
* Куча: память нужно освобождать вручную (`delete`/`delete[]`)
* Классы с динамическими ресурсами: освобождать в деструкторе

---

## 5. Ссылки и указатели

### 5.1 Ссылка (`&`)

```cpp
int x = 10;          // обычная переменная
int& ref = x;        // ссылка — "другое имя для x"
ref = 20;            // меняем значение через ref
std::cout << x;      // 20
```

### 5.2 Указатель (`*`)

```cpp
int y = 5;
int* p = &y;         // p хранит адрес y
*p = 7;              // разыменовываем указатель
std::cout << y;      // 7
```

---

## 6. Передача аргументов в функции

### 6.1 По значению

```cpp
void f(int x) {
    x = 10; // меняем копию, оригинал не изменится
}

int a = 5;
f(a);
std::cout << a; // 5
```

* Копия передаётся в функцию → оригинал не меняется
* Минус: для больших структур/векторов медленно

### 6.2 По ссылке

```cpp
void f(int& x) {
    x = 10; // меняем оригинал
}

int a = 5;
f(a);
std::cout << a; // 10
```

* Экономно (нет копирования)
* Можно изменить оригинал

### 6.3 По указателю

```cpp
void f(int* x) {
    *x = 10; // меняем оригинал через разыменование
}

int a = 5;
f(&a);
std::cout << a; // 10
```

* Нужно передавать адрес (`&`)
* Более явный синтаксис, можно менять оригинал

---

## 7. Цикл `for`

```cpp
for (int i = 0; i < 5; ++i) { // инициализация; условие; шаг
    std::cout << i << " ";     // тело цикла
}
```

* `i = 0` — объявление и инициализация переменной
* `i < 5` — условие продолжения
* `++i` — шаг после каждой итерации

---

## 8. Функции

```cpp
int add(int a, int b) {        // прототип функции: возвращаемый тип, имя, аргументы
    return a + b;              // тело функции — что она делает
}

void printVector(const std::vector<int>& v) { // передача по const ссылке
    for (int x : v) std::cout << x << " ";    // тело функции
    std::cout << "\n";
}
```

---

## 9. Вектор (`std::vector`)

```cpp
std::vector<int> v;         // создаём пустой вектор
v.push_back(10);            // добавляем элемент
v.push_back(20);
std::cout << v[0];          // 10
std::cout << v.size();      // 2
std::sort(v.begin(), v.end()); // сортировка
```

---

## 10. Динамический массив

```cpp
int n = 5;
int* arr = new int[n];      // выделяем память в куче

for (int i = 0; i < n; i++) arr[i] = i*i; // заполняем

for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
std::cout << "\n";

delete[] arr;               // освобождаем память после использования
```

---

## 11. Классы, структуры, методы и friend

```cpp
class Point {
public:
    int x, y;                  // поля класса

    Point(int a, int b) {      // конструктор
        x = a; y = b;
    }

    void move(int dx, int dy) { // метод
        x += dx; y += dy;
    }

    ~Point() {                 // деструктор
        std::cout << "Destroyed\n";
    }
};

struct PointStruct {           // struct по умолчанию public
    int x, y;
    void move(int dx, int dy) { x+=dx; y+=dy; }
};

// friend функция для доступа к private
class MyClass {
private:
    int secret;
public:
    MyClass(int s): secret(s) {}
    friend void reveal(const MyClass& obj);
};

void reveal(const MyClass& obj) {
    std::cout << obj.secret << "\n"; // доступ к private
}
```

---

## 12. Битовые операции

```cpp
int a = 5;  // 0101 в двоичной
int b = 3;  // 0011

int c = a & b;  // побитовое AND → 1 (0101 & 0011 = 0001)
int d = a | b;  // побитовое OR → 7 (0101 | 0011 = 0111)
int e = a ^ b;  // побитовое XOR → 6 (0101 ^ 0011 = 0110)
int f = ~a;     // побитовое NOT → -6 (инвертируем все биты)
int g = a << 1; // сдвиг влево → 10 (0101 << 1 = 1010)
int h = a >> 1; // сдвиг вправо → 2 (0101 >> 1 = 0010)
```

---

## 13. Правила delete

```cpp
Point* p = new Point(1,2);  // один объект в куче
delete p;                    // используем delete для одиночного объекта

int* arr = new int[5];       // массив в куче
delete[] arr;                // используем delete[] для массивов
```

* Один объект → `delete`
* Массив → `delete[]`
* Без delete → утечки памяти

---

## 14. Общие правила памяти

* **Стек**: переменные уничтожаются автоматически при выходе из функции или блока
* **Куча**: память нужно освобождать вручную
* **Деструкторы**: используем для автоматического освобождения ресурсов в классах
* **Передача по ссылке/указателю** экономит память и ускоряет работу, но меняет оригинал


